{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Main where

import TrapGen.Point
import TrapGen.Number
import TrapGen.InputDefinitions

import Control.Monad.Trans.State.Strict
import Data.Foldable (find)
import Data.Monoid ((<>))
import Data.Text (Text, pack, unpack, intercalate)
import qualified Data.Text as T

import System.Environment (getArgs)
import System.IO (writeFile)
import System.Random (RandomGen, getStdGen)


main :: IO ()
--main = readParameters "./data.json" >>= putStrLn . show
--mai1 :: IO ()
main = do args <- getArgs
          case args of [a1, a2] -> writeTph a1 a2
                       _ -> error "Usage: trapgen <input path> <output path>"

  where writeTph :: FilePath -> FilePath -> IO ()
        writeTph fin fout = do ep <- readParameters fin
                               case ep of Left e -> error $ "JSON parse error: " ++ show e
                                          Right p -> do g <- getStdGen
                                                        let tph = evalState (genTph p) g 
                                                        writeFile fout (unpack tph)



genTph :: forall g . RandomGen g => Parameters -> State g Text
genTph (Parameters efs ars) = do txt <- mconcat <$> mapM genArea ars
                                 return $ "// Autogenerated by trapgen\n\n" <> txt

  where nest1 = "\n    "
        nest2 = "\n            "

       
        genArea :: Area -> State g Text
        genArea (Area (TextId a_id) grps) = do txt <- mconcat <$> mapM genGroup grps
                                               return $ "COPY_EXISTING ~" <> a_id <> ".ARE~ ~override/" <> a_id <> ".ARE~\n\n" <> txt

        genGroup :: TrapGroup -> State g Text
        genGroup (TrapGroup (TextId gid) trps) = do txt <- mconcat <$> mapM genTrap trps
                                                    return $ "// GROUP " <> gid <> ":\n\n" <> txt

          where genTrap :: Trap -> State g Text
                genTrap t = do verts <- genVerts (trap_geometry t)
                               script <- genScript (trap_effect t)
                               detect <- genNum (trap_detect t)
                               disarm <- genNum (trap_disarm t)
                               let (TextId trapid) = trap_id t
                               let prefix = T.take 31 $ T.concat ["trapgen_", gid, "_", trapid]
                               return $ T.concat [ "LPF add_are_trap"
                                                 , nest1, "INT_VAR trap_detect = ", detect, " trap_disarm = ", disarm
                                                 , nest2, verts
                                                 , nest1, "STR_VAR trap_script = ~", script, "~ trap_name = ~", prefix, "~\n"
                                                 , "END\n\n"
                                                 ]

        genVerts :: TrapGeometry -> State g Text
        genVerts (GeometryPoints pts) = intercalate nest2 <$> mapM genCoord (zip [0..] pts)

        genCoord :: (Int, Coord) -> State g Text
        genCoord (i, (Point x y)) = do x' <- genNum x 
                                       y' <- genNum y
                                       let i' = tx i
                                       return $ T.concat ["x", i', " = ", x', " y", i', " = ", y']

        genScript :: TrapEffect -> State g Text
        genScript (EffectFixed s) = return s
        genScript (EffectRandom f_id t_id) = 
            case find ((f_id==) . flavor_id) efs of 
                 Nothing -> error $ "Flavor '" ++ show f_id ++ "'not found"
                 Just f -> case find ((t_id==) . tier_id) (flavor_tiers f) of
                                Nothing -> error $ "Tier '" ++ show t_id ++ "' not found in flavor '" ++ show f_id ++ "'"
                                Just t -> let ss = tier_scripts t in
                                          do i <- genNumber $ Range 0 (length ss - 1)
                                             return $ ss !! i


        tx = pack . show

        genNum :: Number -> State g Text
        genNum = fmap tx . genNumber



